<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils/repoProductos.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils/repoProductos.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// utils/repoProductos.js — refactor limpio con JSDoc (fetch, sin Axios)
import { db } from './db';
import { apiFoodTrucks } from './api';
import Resizer from 'react-image-file-resizer';

// ======================== CORRECCIÓN JSDOC ========================

/**
 * @typedef {'ACTIVO' | 'INACTIVO' | 'EN_REVISION' | boolean} EstadoProducto
 */

/** @typedef {Object} ProductApi
 * @property {number|string} producto_id
 * @property {number|string|null} [categoria_id]
 * @property {string} [categoria_nombre]
 * @property {string} [nombre]
 * @property {string} [descripcion]
 * @property {string|number} [precio_base]
 * @property {number} [tiempo_preparacion]
 * @property {boolean|0|1|'0'|'1'|'true'|'false'|'Publicado'|'Borrador'} [estado]
 * @property {string} [fecha_creacion]
 * @property {string|null} [imagen_url]
 * @property {string|null} [imagen]
 */

/** @typedef {Object} ProductForm
 * @property {number|string|null} [categoria_id]
 * @property {string} [categoria_nombre]
 * @property {string} [nombre]
 * @property {string} [descripcion]
 * @property {string|number} [precio_base]
 * @property {number|string} [tiempo_preparacion]
 * @property {boolean|0|1|'0'|'1'|'true'|'false'|'Publicado'|'Borrador'} [estado]
 * @property {string} [imagen_url]
 * @property {File} [imagen_file]
 */

/** @typedef {Object} ProductLocal
 * @property {string} producto_id
 * @property {string|number|null} [categoria_id]
 * @property {string} [categoria_nombre]
 * @property {string} [nombre]
 * @property {string} [descripcion]
 * @property {number} [precio_base]
 * @property {number} [tiempo_preparacion]
 * @property {boolean} [estado]
 * @property {string} [fecha_creacion]
 * @property {string} [imagen_url]
 */

// CORRECCIÓN LÍNEAS 45 y 47
/**
 * @typedef {object} ResultsContainer
 * @property {Array&lt;any>} [results] - Lista de resultados opcional.
 */
/**
 * @typedef {object} DataContainer
 * @property {object} [data]
 * @property {Array&lt;any>} [data.results]
 */
/**
 * @typedef {ResultsContainer|DataContainer|Array&lt;any>} ListLike - Tipo para estructuras de respuesta de lista.
 */

const ENDPOINT_BASE = 'v1/productos/';
const productoImagenEndpoint = (id) => `v1/productos/${id}/imagen/`;

// ======================== UTILIDADES ========================

/**
 * Desenvuelve una respuesta posible de fetch o un wrapper que ya retorna JSON.
 * @param {any} resp
 * @returns {Promise&lt;any>}
 */
async function unwrapResponse(resp) {
  // Si es Response de fetch
  if (resp &amp;&amp; typeof resp === 'object' &amp;&amp; typeof resp.json === 'function') {
    const clone = resp.clone?.() ?? resp;
    return clone.json();
  }
  // Si ya es data (wrapper de fetch)
  return resp;
}

/**
 * Extrae el ID desde diferentes formas soportadas por el backend.
 * @param {any} obj
 * @returns {string}
 */
function extractId(obj) {
  if (!obj || typeof obj !== 'object') return '';
  const direct = obj.producto_id ?? obj.id ?? obj.pk ?? obj.uuid;
  if (direct != null) return String(direct);
  const nested =
    obj.producto?.producto_id ??
    obj.producto?.id ??
    obj.producto?.pk ??
    obj.producto?.uuid;
  return nested != null ? String(nested) : '';
}

/**
 * Normaliza un booleano "estado" desde múltiples representaciones.
 * @param {any} v
 * @returns {boolean}
 */
function normalizeEstado(v) {
  if (
    v === true ||
    v === 1 ||
    v === '1' ||
    (typeof v === 'string' &amp;&amp; v.toLowerCase() === 'true') ||
    v === 'Publicado'
  )
    return true;
  if (
    v === false ||
    v === 0 ||
    v === '0' ||
    (typeof v === 'string' &amp;&amp; v.toLowerCase() === 'false') ||
    v === 'Borrador'
  )
    return false;
  return !!v;
}

/**
 * Convierte una cadena de dinero a "##.##" (string) o vacío si no válido.
 * @param {string|number} val
 * @returns {string}
 */
function normalizeMoneyString(val) {
  if (val == null) return '';
  const s = String(val)
    .replace(/[^0-9.,]/g, '')
    .replace(',', '.');
  const n = Number(s);
  if (Number.isNaN(n)) return '';
  return n.toFixed(2);
}

/**
 * Selecciona una lista desde diversas formas de respuesta.
 * @param {ListLike} res
 * @returns {any[]}
 */
function pickList(res) {
  if (Array.isArray(res?.results)) return res.results;
  if (Array.isArray(res?.data?.results)) return res.data.results;
  if (Array.isArray(res)) return res;
  return [];
}

/**
 * Selecciona un objeto desde diversas formas de respuesta.
 * @param {any} res
 * @returns {any}
 */
function pickObject(res) {
  return res?.data ?? res?.result ?? res ?? null;
}

// ======================== MAPEOS ========================

/**
 * Mapea del objeto API al objeto local persistido.
 * @param {ProductApi} p
 * @returns {ProductLocal}
 */
function mapProductFromApi(p) {
  return {
    producto_id: String(p.producto_id),
    categoria_id: p.categoria_id ?? '',
    categoria_nombre: p.categoria_nombre ?? '',
    nombre: p.nombre ?? '',
    descripcion: p.descripcion ?? '',
    precio_base: Number(p.precio_base ?? 0),
    tiempo_preparacion: Number(p.tiempo_preparacion ?? 0),
    estado: normalizeEstado(p.estado),
    fecha_creacion: p.fecha_creacion ?? '',
    imagen_url: p.imagen_url ?? p.imagen ?? '',
  };
}

/**
 * Mapea del formulario local al payload esperado por la API.
 * Solo incluye `imagen_url` si está presente para no sobreescribir.
 * @param {ProductForm} form
 * @returns {Record&lt;string, any>}
 */
function mapProductToApi(form) {
  const obj = {
    categoria_id: form.categoria_id || null,
    nombre: form.nombre?.trim() || '',
    descripcion: form.descripcion?.trim() || '',
    precio_base: normalizeMoneyString(form.precio_base),
    tiempo_preparacion: Number(form.tiempo_preparacion || 0),
    estado: normalizeEstado(form.estado),
  };
  const img = (form.imagen_url ?? '').trim();
  if (img) obj.imagen_url = img;
  return obj;
}

/**
 * Construye un JSON de actualización, omitiendo campos vacíos.
 * @param {ProductForm} form
 * @returns {Record&lt;string, any>}
 */
function buildUpdateJson(form) {
  const body = {};
  if (form.categoria_id != null &amp;&amp; String(form.categoria_id).trim() !== '')
    body.categoria_id = Number(form.categoria_id);
  if (form.nombre &amp;&amp; String(form.nombre).trim() !== '')
    body.nombre = String(form.nombre).trim();
  if (form.descripcion &amp;&amp; String(form.descripcion).trim() !== '')
    body.descripcion = String(form.descripcion).trim();
  const precio = normalizeMoneyString(form.precio_base);
  if (precio) body.precio_base = precio;
  if (
    form.tiempo_preparacion != null &amp;&amp;
    String(form.tiempo_preparacion).trim() !== ''
  )
    body.tiempo_preparacion = Number(form.tiempo_preparacion);
  if ('estado' in form) body.estado = normalizeEstado(form.estado);
  const img = (form.imagen_url ?? '').trim();
  if (img) body.imagen_url = img;
  return body;
}

// ======================== IMÁGENES ========================

/**
 * Convierte un dataURL a File.
 * @param {string} dataUrl
 * @param {string} [filename]
 * @param {string} [type]
 * @returns {File}
 */
function fileFromDataUrl(
  dataUrl,
  filename = 'image.webp',
  type = 'image/webp'
) {
  const arr = dataUrl.split(',');
  const bstr = atob(arr[1]);
  let n = bstr.length;
  const u8arr = new Uint8Array(n);
  while (n--) u8arr[n] = bstr.charCodeAt(n);
  return new File([u8arr], filename, { type });
}

// CORRECCIÓN LÍNEAS 235 y 241
/**
 * Redimensiona/convierte una imagen a WebP del lado cliente.
 * @param {File} file
 * @param {object} [opts] - Opciones para el redimensionamiento de la imagen.
 * @property {number} [opts.maxWidth] - Ancho máximo deseado (def. 1600).
 * @property {number} [opts.maxHeight] - Altura máxima deseada (def. 1600).
 * @property {number} [opts.quality] - Calidad de la imagen (0 a 100) (def. 82).
 * @returns {Promise&lt;File>}
 */
function toWebpFile(
  file,
  { maxWidth = 1600, maxHeight = 1600, quality = 82 } = {}
) {
  return new Promise((resolve, reject) => {
    try {
      Resizer.imageFileResizer(
        file,
        maxWidth,
        maxHeight,
        'WEBP',
        quality,
        0,
        (uri) => {
          const base = (file.name || 'upload').replace(/\.[^.]+$/, '');
          resolve(fileFromDataUrl(uri, `${base}.webp`, 'image/webp'));
        },
        'base64'
      );
    } catch (err) {
      reject(err);
    }
  });
}

/**
 * Sube la imagen del producto vía `POST /v1/productos/:id/imagen/`.
 * El backend se encarga de guardar en blob storage y persistir `imagen_url`.
 * @param {string|number} productoId
 * @param {File} file
 * @returns {Promise&lt;string>} `imagen_url` si la API la devuelve (puede ser "" si se persiste async)
 */
async function uploadImagenProducto(productoId, file) {
  if (!file) return '';

  let toUpload = file;
  if (file.type !== 'image/webp') {
    try {
      toUpload = await toWebpFile(file, {
        maxWidth: 1600,
        maxHeight: 1600,
        quality: 82,
      });
    } catch {
      toUpload = file;
    }
  }

  const fd = new FormData();
  const filename =
    toUpload.name ||
    (file.name ? file.name.replace(/\.[^.]+$/, '.webp') : 'upload.webp');
  // Cambia 'imagen' si tu backend usa otro nombre de campo (p. ej. 'image' o 'foto')
  fd.append('imagen', toUpload, filename);

  const resp = await apiFoodTrucks.post(productoImagenEndpoint(productoId), fd);
  const data = await unwrapResponse(resp);
  const obj = data?.producto ?? data;
  const imagen_url = obj?.imagen_url ?? '';
  return imagen_url;
}

/**
 * Obtiene un producto por ID desde la API (para refrescar campos como `imagen_url`).
 * @param {string|number} id
 * @returns {Promise&lt;ProductApi|null>}
 */
async function fetchProducto(id) {
  const res = await apiFoodTrucks.get(`${ENDPOINT_BASE}${id}/`);
  const data = await unwrapResponse(res);
  return data?.producto ?? data ?? null;
}

/**
 * Espera a que `imagen_url` esté disponible en el backend (reintentos cortos).
 * @param {string|number} id
 * @param {number} [maxTries]
 * @param {number} [delayMs]
 * @returns {Promise&lt;ProductLocal|null>}
 */
async function waitForImagenUrl(id, maxTries = 3, delayMs = 400) {
  for (let i = 0; i &lt; maxTries; i++) {
    const obj = await fetchProducto(id);
    const mapped = obj ? mapProductFromApi(obj) : null;
    if (mapped?.imagen_url) return mapped;
    await new Promise((r) => setTimeout(r, delayMs));
  }
  return null;
}

// ======================== OUTBOX ========================

const online = () =>
  typeof navigator !== 'undefined' ? navigator.onLine : true;

async function pushOutboxItem(item) {
  await db.outbox.add({ ...item, status: 'pending', ts: Date.now() });
}

async function processOutboxItem(item) {
  try {
    switch (item.method) {
      case 'POST': {
        const createdRes = await apiFoodTrucks.post(item.endpoint, item.body);
        const data = await unwrapResponse(createdRes);
        const obj = data?.producto ?? data;
        if (!obj || obj.producto_id == null) break;
        const prod = mapProductFromApi(obj);
        await db.productos_v2.put(prod);
        break;
      }
      case 'PUT': {
        const updatedRes = await apiFoodTrucks.put(item.endpoint, item.body);
        const data = await unwrapResponse(updatedRes);
        const endpointId = String(
          item.endpoint.split('/').filter(Boolean).pop()
        );
        const obj = data?.producto ?? data;
        const updated = mapProductFromApi(
          obj || { ...item.body, producto_id: endpointId }
        );
        await db.productos_v2.put(updated);
        break;
      }
      case 'PATCH': {
        const patchedRes = await apiFoodTrucks.patch(item.endpoint, item.body);
        const data = await unwrapResponse(patchedRes);
        const endpointId = String(
          item.endpoint.split('/').filter(Boolean).pop()
        );
        const current = await db.productos_v2.get(endpointId);
        const obj = data?.producto ?? data;
        const merged = mapProductFromApi(
          obj || { ...current, ...item.body, producto_id: endpointId }
        );
        await db.productos_v2.put(merged);
        break;
      }
      case 'DELETE': {
        await apiFoodTrucks.delete(item.endpoint);
        break;
      }
      default:
        throw new Error(`Método no soportado: ${item.method}`);
    }
    await db.outbox.update(item.id, { status: 'done' });
  } catch (e) {
    await db.outbox.update(item.id, {
      status: 'error',
      error: String(e?.message || e),
    });
    throw e;
  }
}

async function flushOutbox() {
  const pending = await db.outbox
    .where('status')
    .equals('pending')
    .sortBy('ts');
  for (const it of pending) {
    try {
      await processOutboxItem(it);
    } catch {}
  }
}

// ======================== REPO ========================

export const productosRepo = {
  /**
   * Lista productos. Intenta red desde API y sincroniza cache local.
   * @returns {Promise&lt;{items: ProductLocal[], source: 'network'|'cache'}>}
   */
  async list() {
    try {
      const res = await apiFoodTrucks.get(ENDPOINT_BASE);
      const data = await unwrapResponse(res);
      const items = pickList(data).map((x) =>
        mapProductFromApi(x.producto ?? x)
      );
      await db.transaction('rw', db.productos_v2, async () => {
        await db.productos_v2.clear();
        await db.productos_v2.bulkPut(items);
      });
      if (online()) flushOutbox().catch(() => {});
      return { items, source: 'network' };
    } catch (err) {
      const cached = await db.productos_v2.toArray();
      cached.sort((a, b) =>
        (b.fecha_creacion || '').localeCompare(a.fecha_creacion || '')
      );
      return { items: cached, source: 'cache' };
    }
  },

  /**
   * Crea un producto. Si viene `imagen_file`, la sube y espera URL (con reintentos cortos).
   * @param {ProductForm} form
   * @returns {Promise&lt;ProductLocal>}
   */
  async create(form) {
    const tempId = `tmp-${Date.now()}`;
    await db.productos_v2.put({
      producto_id: tempId,
      categoria_id: form.categoria_id ?? '',
      categoria_nombre: form.categoria_nombre ?? '',
      nombre: form.nombre ?? '',
      descripcion: form.descripcion ?? '',
      precio_base: Number(form.precio_base ?? 0),
      tiempo_preparacion: Number(form.tiempo_preparacion ?? 0),
      estado: normalizeEstado(form.estado),
      fecha_creacion: new Date().toISOString(),
      imagen_url: form.imagen_url ?? '',
    });

    try {
      // 1) Crear producto (sin imagen)
      const body = buildUpdateJson(form);
      const createdRes = await apiFoodTrucks.post(ENDPOINT_BASE, body);
      const unwrapped = await unwrapResponse(createdRes);
      const data = unwrapped?.producto ?? unwrapped;
      const newId = extractId(data);
      if (!newId)
        throw new Error('No se obtuvo producto_id tras crear el producto');

      let prod = mapProductFromApi({ ...data, producto_id: newId });

      // 2) Subir imagen (si hay) → backend persiste imagen_url
      if (form.imagen_file) {
        const uploadedUrl = await uploadImagenProducto(newId, form.imagen_file);
        if (uploadedUrl) {
          prod = { ...prod, imagen_url: uploadedUrl };
        } else {
          const refreshed = await waitForImagenUrl(newId, 3, 400);
          if (refreshed) prod = refreshed;
        }
      }

      // 3) Guardar versión definitiva local
      await db.transaction('rw', db.productos_v2, async () => {
        await db.productos_v2.delete(tempId);
        await db.productos_v2.put(prod);
      });

      return prod;
    } catch (e) {
      await db.productos_v2.delete(tempId);
      throw e;
    }
  },

  /**
   * Actualiza un producto. Si viene nueva imagen, se sube primero y luego se PUTean los otros campos.
   * @param {string|number} producto_id
   * @param {ProductForm} form
   * @returns {Promise&lt;ProductLocal|void>}
   */
  async update(producto_id, form) {
    const id = String(producto_id);
    const hasNewImage = !!form?.imagen_file;

    if (hasNewImage) {
      const uploadedUrl = await uploadImagenProducto(id, form.imagen_file);

      const prev = await db.productos_v2.get(id);
      const nextLocal = {
        ...prev,
        ...form,
        producto_id: id,
        imagen_url: uploadedUrl || prev?.imagen_url || '',
        precio_base: Number(form.precio_base ?? prev?.precio_base ?? 0),
        tiempo_preparacion: Number(
          form.tiempo_preparacion ?? prev?.tiempo_preparacion ?? 0
        ),
        estado: normalizeEstado(form.estado),
      };
      await db.productos_v2.put(nextLocal);

      // Refrescar imagen_url desde backend si aún no vino
      const refreshed = await waitForImagenUrl(id, 3, 400);
      if (refreshed) await db.productos_v2.put(refreshed);

      // PUT de otros campos (sin imagen_url)
      const body = buildUpdateJson(form);
      const hasOtherFields = Object.keys(body).length > 0;
      if (hasOtherFields) {
        const updatedRes = await apiFoodTrucks.put(
          `${ENDPOINT_BASE}${id}/`,
          body
        );
        const data = await unwrapResponse(updatedRes);
        const obj = data?.producto ?? data;
        const updated = mapProductFromApi(obj || { ...body, producto_id: id });
        await db.productos_v2.put(updated);
        return updated;
      }
      return nextLocal;
    }

    // Sin nueva imagen
    const desiredEstado = normalizeEstado(form.estado);
    const prev = await db.productos_v2.get(id);
    await db.productos_v2.put({
      ...prev,
      ...form,
      producto_id: id,
      estado: desiredEstado,
      precio_base: Number(form.precio_base ?? prev?.precio_base ?? 0),
      tiempo_preparacion: Number(
        form.tiempo_preparacion ?? prev?.tiempo_preparacion ?? 0
      ),
    });

    await pushOutboxItem({
      method: 'PUT',
      endpoint: `${ENDPOINT_BASE}${id}/`,
      body: mapProductToApi(form),
    });

    if (!prev || prev.estado !== desiredEstado) {
      await pushOutboxItem({
        method: 'PATCH',
        endpoint: `${ENDPOINT_BASE}${id}/`,
        body: { estado: desiredEstado },
      });
    }

    if (online()) {
      await flushOutbox();
      try {
        await this.syncPending();
      } catch {}
    }
  },

  // CORRECCIÓN LÍNEAS 577 y 582
  /**
   * Actualiza solo el estado (PATCH).
   * @param {string|number} producto_id
   * @param {EstadoProducto} estado - El estado del producto a actualizar.
   */
  async patchEstado(producto_id, estado) {
    const val = normalizeEstado(estado);
    const p = await db.productos_v2.get(producto_id);
    if (p) await db.productos_v2.put({ ...p, estado: val });
    await pushOutboxItem({
      method: 'PATCH',
      endpoint: `${ENDPOINT_BASE}${producto_id}/`,
      body: { estado: val },
    });
    if (online()) {
      await flushOutbox();
      try {
        await this.syncPending();
      } catch {}
    }
  },

  /**
   * Remueve local y encola DELETE en outbox.
   * @param {string|number} producto_id
   */
  async remove(producto_id) {
    await db.productos_v2.delete(producto_id);
    await pushOutboxItem({
      method: 'DELETE',
      endpoint: `${ENDPOINT_BASE}${producto_id}/`,
    });
    if (online()) {
      await flushOutbox();
      try {
        await this.syncPending();
      } catch {}
    }
  },

  /**
   * Elimina definitivamente (hard=1) con rollback local en caso de error.
   * @param {string|number} producto_id
   */
  async destroy(producto_id) {
    const id = String(producto_id);
    const before = await db.productos_v2.get(id);
    if (before) await db.productos_v2.delete(id);
    try {
      const url = `${ENDPOINT_BASE}${id}/?hard=1`;
      await apiFoodTrucks.delete(url);
      return;
    } catch (e) {
      if (before) await db.productos_v2.put(before);
      throw e;
    }
  },

  /**
   * Sincroniza cola pendiente y refresca cache local desde la API.
   */
  async syncPending() {
    if (!online()) return;
    await flushOutbox();
    try {
      const res = await apiFoodTrucks.get(ENDPOINT_BASE);
      const data = await unwrapResponse(res);
      const items = pickList(data).map((x) =>
        mapProductFromApi(x.producto ?? x)
      );
      await db.transaction('rw', db.productos_v2, async () => {
        await db.productos_v2.clear();
        await db.productos_v2.bulkPut(items);
      });
    } catch (e) {
      // noop: nos quedamos con cache
    }
  },
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#buildUpdateJson">buildUpdateJson</a></li><li><a href="global.html#extractId">extractId</a></li><li><a href="global.html#fetchProducto">fetchProducto</a></li><li><a href="global.html#fileFromDataUrl">fileFromDataUrl</a></li><li><a href="global.html#mapProductFromApi">mapProductFromApi</a></li><li><a href="global.html#mapProductToApi">mapProductToApi</a></li><li><a href="global.html#normalizeEstado">normalizeEstado</a></li><li><a href="global.html#normalizeMoneyString">normalizeMoneyString</a></li><li><a href="global.html#pickList">pickList</a></li><li><a href="global.html#pickObject">pickObject</a></li><li><a href="global.html#toWebpFile">toWebpFile</a></li><li><a href="global.html#unwrapResponse">unwrapResponse</a></li><li><a href="global.html#uploadImagenProducto">uploadImagenProducto</a></li><li><a href="global.html#useCurrentUser">useCurrentUser</a></li><li><a href="global.html#waitForImagenUrl">waitForImagenUrl</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Sun Nov 02 2025 00:16:43 GMT-0300 (hora de verano de Chile)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
